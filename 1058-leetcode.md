---
title: LeetCode 1058. Minimize Rounding Error to Meet Target - 
description: Placeholder
date: 2025-09-21
categories: []
author: moses
tags: []
hideToc: true
---
        ## ‚úÖ Minimize Rounding Error ‚Äì LeetCode‚ÄØ1058  
**Solve it in Java, Python and C++**  
**+ Blog post (SEO‚Äëfriendly, ‚Äúthe good, the bad & the ugly‚Äù)**  

---

### 1Ô∏è‚É£ Problem Recap

| # | Problem | Difficulty | Link |
|---|---------|------------|------|
| 1058 | **Minimize Rounding Error to Meet Target** | Medium | <https://leetcode.com/problems/minimize-rounding-error-to-meet-target/> |

*Given an array `prices[]` (each string has exactly 3 decimal digits) and an integer `target`. For each price `pi` you may replace it by either `floor(pi)` or `ceil(pi)`. Choose the replacements so that the sum equals `target`. If it‚Äôs impossible, return ‚Äú-1‚Äù. Otherwise return the **minimum** rounding error:  

\[
\text{error}=\sum_{i=1}^{n}\lvert \text{rounded}_i - p_i\rvert
\]  

The answer has to be formatted with exactly three decimal places.*

---

### 2Ô∏è‚É£ Why ‚ÄúRounding Error‚Äù is a **Hidden DP + Greedy** Problem

* You only need to decide **which** of the two integer values (`floor` or `ceil`) you‚Äôll use for each price.
* The change of the sum caused by a floor/ceil decision is **identical** for all prices:
  * `ceil(pi)`  ‚Üí  adds `1 - frac_i` to the error  
  * `floor(pi)` ‚Üí  adds `frac_i`      to the error  
  * (where `frac_i = pi ‚Äì floor(pi)` is the fractional part, 0‚ÄØ‚â§‚ÄØfrac_i‚ÄØ<‚ÄØ1)

So once we know how many floors we *must* use, the *ordering* of the prices becomes irrelevant ‚Äì we simply choose the smallest fractional parts to floor, because that gives the smallest error. This is a classic ‚Äúsort‚Äëand‚Äëtake‚Äù greedy algorithm that runs in **O(n‚ÄØlog‚ÄØn)** time.

---

## 2Ô∏è‚É£ Solution Overview (Integer‚ÄëOnly Implementation)

Each price string can be safely converted to an **integer that represents the price √ó‚ÄØ1000**.  
This removes any floating‚Äëpoint precision issue and lets us do all arithmetic with plain integers.

| Step | What we compute | Why it matters |
|------|-----------------|----------------|
| 1 | `priceInt = whole*1000 + frac` | Exact 3‚Äëdigit integer |
| 2 | `ceilUnits = (priceInt + 999) // 1000` | `ceil(pi)` in whole‚Äënumber units |
| 3 | `frac = (priceInt % 1000) / 1000.0` | Fractional part for the error |
| 4 | `sumCeilUnits = Œ£ ceilUnits` | Maximal achievable sum |
| 5 | `floorsNeeded = sumCeilUnits ‚Äì target` | How many **non‚Äëinteger** prices must be floored |
| 6 | Sort all `frac` ascending | The smallest fractions come first |
| 7 | For the first `floorsNeeded` fractional values (‚â†‚ÄØ0) pick **floor** (`error += frac`).  
    For all other positions pick **ceil** (`error += 1‚Äëfrac`). | Gives the minimal total error |

If `sumCeilUnits < target` or `floorsNeeded` exceeds the number of *non‚Äëinteger* prices, the task is impossible ‚Üí ‚Äú-1‚Äù.

The final error is printed with exactly three decimal places.

---

## 3Ô∏è‚É£ Code (Java)

```java
import java.util.*;

class Solution {
    public String minimizeError(String[] prices, int target) {
        int n = prices.length;
        int sumCeilUnits = 0;            // sum of ceil(pi) as whole numbers
        int nonIntCount = 0;             // how many pi are NOT integers
        double[] frac = new double[n];   // fractional parts

        for (int i = 0; i < n; i++) {
            String s = prices[i];
            int dot = s.indexOf('.');
            int whole = Integer.parseInt(s.substring(0, dot));
            int fracPart = Integer.parseInt(s.substring(dot + 1)); // 3 digits
            int priceInt = whole * 1000 + fracPart; // price * 1000

            int ceilUnits = (priceInt + 999) / 1000; // ceil(pi)
            sumCeilUnits += ceilUnits;

            frac[i] = (priceInt % 1000) / 1000.0; // exact fractional part
            if (priceInt % 1000 != 0) nonIntCount++;
        }

        if (sumCeilUnits < target) return "-1";

        int floorsNeeded = sumCeilUnits - target;
        if (floorsNeeded > nonIntCount) return "-1";

        Arrays.sort(frac);   // zeros go first, then small fractions

        double error = 0.0;
        for (double f : frac) {
            if (f == 0.0) {
                // integer price ‚Äì floor == ceil, no error
                continue;
            }
            if (floorsNeeded > 0) {
                // choose floor
                error += f;
                floorsNeeded--;
            } else {
                // choose ceil
                error += 1.0 - f;
            }
        }

        // after the loop floorsNeeded must be 0
        return String.format(Locale.US, "%.3f", error);
    }
}
```

---

## 4Ô∏è‚É£ Code (Python)

```python
from typing import List

class Solution:
    def minimizeError(self, prices: List[str], target: int) -> str:
        n = len(prices)
        sumCeilUnits = 0
        frac = [0.0] * n
        non_int = 0

        for i, s in enumerate(prices):
            whole, frac_part = s.split('.')
            whole = int(whole)
            frac_part = int(frac_part)          # always 3 digits
            price_int = whole * 1000 + frac_part

            ceil_units = (price_int + 999) // 1000
            sumCeilUnits += ceil_units

            f = (price_int % 1000) / 1000.0
            frac[i] = f
            if f > 0.0:
                non_int += 1

        if sumCeilUnits < target:
            return "-1"

        floors_needed = sumCeilUnits - target
        if floors_needed > non_int:
            return "-1"

        frac.sort()
        error = 0.0
        for f in frac:
            if f == 0.0:
                continue  # integer price, no error
            if floors_needed > 0:
                error += f
                floors_needed -= 1
            else:
                error += 1.0 - f

        # floors_needed must be 0 here
        return f"{error:.3f}"
```

---

## 5Ô∏è‚É£ Code (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    string minimizeError(vector<string> &prices, int target) {
        int n = prices.size();
        long long sumCeil = 0;          // sum of ceil(pi) as whole numbers
        vector<double> frac(n);         // fractional parts
        int nonInt = 0;

        for (int i = 0; i < n; ++i) {
            const string &s = prices[i];
            int dot = s.find('.');
            int whole = stoi(s.substr(0, dot));
            int fracPart = stoi(s.substr(dot + 1));   // always 3 digits
            int priceInt = whole * 1000 + fracPart;   // price * 1000

            int ceilUnits = (priceInt + 999) / 1000;   // ceil(pi)
            sumCeil += ceilUnits;

            frac[i] = (priceInt % 1000) / 1000.0;      // exact fractional part
            if (priceInt % 1000 != 0) ++nonInt;
        }

        if (sumCeil < target) return "-1";

        int floorsNeeded = sumCeil - target;
        if (floorsNeeded > nonInt) return "-1";

        sort(frac.begin(), frac.end());   // zeros first
        double error = 0.0;

        for (double f : frac) {
            if (f == 0.0) continue;      // integer price, no error either way
            if (floorsNeeded > 0) {
                error += f;              // floor
                --floorsNeeded;
            } else {
                error += 1.0 - f;        // ceil
            }
        }

        return to_string(error).substr(0, error < 1e-9 ? 1 : error < 1e-6 ? 4 : 7); // 3 decimals
    }
};
```

> **Why not use `double` for all calculations?**  
> Because every input price has **exactly three** decimal digits, we can store the value as an integer `priceInt = price * 1000`. All arithmetic is then exact, the only floating‚Äëpoint operation left is `error += f` or `1‚Äëf`, which we format to three decimal places in the output.

---

## üìö SEO‚ÄëFriendly Blog Post  
> **Title:** *Minimize Rounding Error ‚Äì The Good, The Bad & The Ugly (LeetCode‚ÄØ1058)*  

---

### üîé 1. Introduction  

Have you ever tried to make a list of prices add up to a specific total while rounding each price up or down?  
LeetCode 1058 is exactly that. In the post below we‚Äôll walk through why the problem is deceptively simple, how a clean integer‚Äëbased algorithm solves it, and the real‚Äëworld pitfalls (the **bad**) and best‚Äëpractice tricks (the **good**).  
We‚Äôll finish with a ‚Äúthe ugly‚Äù section that explains the subtle edge cases that can trip up naive solutions.

---

### 2Ô∏è‚É£ The ‚ÄúGood‚Äù ‚Äì Clean, Exact, O(n‚ÄØlog‚ÄØn)  

* **Integer‚Äëonly arithmetic** ‚Äì Convert `"2.800"` ‚Üí `2800`. No `double` precision worries.  
* **Ceil calculation** ‚Äì `ceilUnits = (priceInt + 999) / 1000`.  
* **Greedy choice** ‚Äì Once we know how many non‚Äëinteger prices must be floored, simply floor the *smallest* fractional parts.  
* **Sorting** ‚Äì The fractional parts array (`frac`) is sorted; zeros go first.  
* **Total error** ‚Äì Sum of `frac` for floored positions plus `1‚Äëfrac` for the rest.  

This approach guarantees the minimal error, and it runs in `O(n‚ÄØlog‚ÄØn)` due to the sort.

---

### 3Ô∏è‚É£ The ‚ÄúBad‚Äù ‚Äì Precision & Edge Cases  

* **Floating‚Äëpoint mis‚Äëconversions** ‚Äì A naive `double` implementation can mis‚Äëinterpret `"0.300"` as `0.299999‚Ä¶`, changing the error.  
* **All‚Äëinteger price lists** ‚Äì If every price is an integer, you might think you can always pick `floor`, but actually the sum never changes.  
* **Too many floors** ‚Äì `floorsNeeded > nonIntCount` should return ‚Äú-1‚Äù, but forgetting this check yields incorrect positive answers.  

These are the subtle traps that many coders run into.

---

### 4Ô∏è‚É£ The ‚ÄúUgly‚Äù ‚Äì Why Sorting Alone is Not Enough  

Even with perfect arithmetic, you *must* verify:
1. **Maximal sum achievable** ‚Äì `sumCeilUnits`.  
2. **Minimum floors required** ‚Äì `floorsNeeded`.  

If you skip either check, you‚Äôll produce an answer that satisfies the sum but not the problem‚Äôs constraints, or worse, you‚Äôll output an error value when the task is impossible.  

---

### 5Ô∏è‚É£ Best‚ÄëPractice Checklist  

| Item | What to Do |
|------|------------|
| **Always count non‚Äëinteger prices** | You cannot floor an integer without affecting the sum. |
| **Validate the target** | `sumCeilUnits` is the upper bound. |
| **Check for impossible floor counts** | `floorsNeeded > nonIntCount` ‚Üí ‚Äú-1‚Äù. |
| **Sort fractional parts** | Smaller fractions ‚Üí smaller error when floored. |
| **Format exactly three decimals** | Use `String.format("%.3f", error)` (Java), `f"{error:.3f}"` (Python), or a manual substring in C++. |

---

### üèÅ 6Ô∏è‚É£ Conclusion  

LeetCode 1058 is a great reminder that many DP or greedy problems hide behind a simple transformation ‚Äì here, turning decimals into integers.  
The clean solution above is both efficient and robust against floating‚Äëpoint quirks.  

If you‚Äôre aiming for that perfect interview score, remember:  
* **Convert first, compute later.**  
* **Always check feasibility before greedily selecting decisions.**  
* **Format correctly ‚Äì three decimals are mandatory!**

Happy coding, and may your sums always round up (or down) exactly as you need them!  

---  

*Author: ChatGPT*  
*Published on 2023‚Äë08‚Äë14*  

--- 

### üéØ Final Thoughts

* **Time Complexity:** O(n‚ÄØlog‚ÄØn) ‚Äì sorting dominates.  
* **Space Complexity:** O(n) ‚Äì storing the fractional parts.  
* **Edge Cases:** Prices that are all integers, a target larger than the maximal sum, or a target that forces too many floors.  
* **Takeaway:** Integer‚Äëonly solutions are the gold standard for problems with fixed decimal precision ‚Äì they‚Äôre simple, fast, and foolproof.

---

And that‚Äôs it! You now have a complete, production‚Äëready solution for LeetCode 1058, along with a blog‚Äëfriendly explanation that can land you points for both algorithmic depth and clean coding style. Happy interviewing! üöÄ

---