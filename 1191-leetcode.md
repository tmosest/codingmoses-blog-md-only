---
title: LeetCode 1191. K-Concatenation Maximum Sum - 
description: Placeholder
date: 2025-09-21
categories: []
author: moses
tags: []
hideToc: true
---
        # üöÄ K‚ÄëConcatenation Maximum Sum ‚Äì Full Solution in **Java, Python & C++**  
> **LeetCode 1470** ‚Äì *Maximum Sum of an Array After K Reversals* (actually K‚Äëconcatenation)  

---

## TL;DR

| Language | Time Complexity | Space Complexity | Final Code |
|----------|-----------------|------------------|------------|
| **Java** | O(n) | O(1) | <details><summary>View Java code</summary>‚Ä¶</details> |
| **Python** | O(n) | O(1) | <details><summary>View Python code</summary>‚Ä¶</details> |
| **C++** | O(n) | O(1) | <details><summary>View C++ code</summary>‚Ä¶</details> |

> **Answer** ‚Äì `maxSubarraySum(duplicatedArray)` when `k==1`.  
> When the total sum of `arr` is negative, the answer comes from the first two concatenations.  
> When the total sum is positive, we add `(k-2) * sum(arr)` to that value.  
> Finally, apply `max(0, answer) % 1_000_000_007`.

---

## Why this matters

For any coding interview or competitive‚Äëprogramming challenge, getting the *right* algorithm that runs in linear time while keeping the code readable is the sweet spot.  
Below you‚Äôll find:

1. A **clean, production‚Äëready** solution for each language.  
2. A **blog post** that dives into the *good*, *bad*, and *ugly* aspects of typical solutions.  
3. SEO‚Äëfriendly titles, headings and keyword usage so the article ranks on search engines for ‚Äúk‚Äëconcatenation maximum sum‚Äù and related queries.

---

## 1. The Problem (LeetCode 1470)

> **K‚ÄëConcatenation Maximum Sum**  
> Given a 1‚ÄëD integer array `arr` and an integer `k`, form an array by concatenating `arr` to itself `k` times.  
> Return the maximum sub‚Äëarray sum possible in this new array.  
> The answer should be taken modulo `10‚Åπ‚ÄØ+‚ÄØ7`. If the maximum sum is negative, return `0`.

Constraints are large (|arr|‚ÄØ‚â§‚ÄØ10‚Åµ, k‚ÄØ‚â§‚ÄØ10‚Åµ) ‚Äì we need an O(n) algorithm, not O(k¬∑n).

---

## 2. The Core Idea (Good)

- **Kadane‚Äôs algorithm** gives the maximum sub‚Äëarray sum of any array in O(n).  
- When we concatenate two copies of `arr` (`k==2`), the maximum sub‚Äëarray can cross the boundary; we need Kadane on a length‚Äë`2¬∑n` array.  
- Let `total = sum(arr)`.  
  * If `total ‚â§ 0`, the best sum cannot be improved by adding more copies, so the answer is just the Kadane on the first two copies.  
  * If `total > 0`, the best sum uses a part that starts in the *first* copy and ends in the *last* copy. All the copies in the middle contribute the full `total` each.  
  Therefore, for `k>2` and `total>0`:

  ```text
  answer = Kadane(arr duplicated twice) + (k-2) * total
  ```

- Finally, take `max(0, answer) % MOD`.

This is the **canonical O(n) solution** that runs in constant extra space.

---

## 3. Full Code

### 3.1 Java

```java
import java.util.*;

class Solution {
    private static final long MOD = 1_000_000_007L;

    public int kConcatenationMaxSum(int[] arr, int k) {
        int n = arr.length;
        long total = 0;
        for (int v : arr) total += v;

        // Kadane for a single copy
        long bestSingle = kadane(arr);

        if (k == 1) return (int)Math.max(bestSingle, 0);

        // Kadane on two copies (size 2*n)
        long bestTwo = kadaneTwoCopies(arr);

        if (total <= 0) {
            return (int)Math.max(bestTwo, 0) % (int)MOD;
        }

        long ans = bestTwo + (k - 2) * total;
        ans %= MOD;
        return (int)Math.max(ans, 0);
    }

    // standard Kadane, works on any array length
    private long kadane(int[] a) {
        long cur = a[0], best = a[0];
        for (int i = 1; i < a.length; i++) {
            cur = Math.max(a[i], cur + a[i]);
            best = Math.max(best, cur);
        }
        return best;
    }

    // Kadane on arr concatenated twice (length 2*n)
    private long kadaneTwoCopies(int[] arr) {
        int n = arr.length;
        long cur = arr[0], best = arr[0];
        for (int i = 1; i < 2 * n; i++) {
            int val = arr[i % n];
            cur = Math.max(val, cur + val);
            best = Math.max(best, cur);
        }
        return best;
    }
}
```

---

### 3.2 Python

```python
MOD = 1_000_000_007

class Solution:
    def kConcatenationMaxSum(self, arr, k: int) -> int:
        n = len(arr)
        total = sum(arr)

        def kadane(a):
            cur = best = a[0]
            for x in a[1:]:
                cur = max(x, cur + x)
                best = max(best, cur)
            return best

        if k == 1:
            ans = kadane(arr)
            return max(ans, 0) % MOD

        # Kadane over two copies
        double = arr * 2
        best_two = kadane(double)

        if total <= 0:
            return max(best_two, 0) % MOD

        ans = (best_two + (k - 2) * total) % MOD
        return max(ans, 0)
```

---

### 3.3 C++

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    static constexpr long long MOD = 1'000'000'007LL;

    int kConcatenationMaxSum(vector<int>& arr, int k) {
        int n = arr.size();
        long long total = 0;
        for (int v : arr) total += v;

        if (k == 1) return static_cast<int>(max(0LL, kadane(arr))) % MOD;

        long long bestTwo = kadaneTwoCopies(arr);
        if (total <= 0) return static_cast<int>(max(0LL, bestTwo)) % MOD;

        long long ans = (bestTwo + (k - 2) * total) % MOD;
        return static_cast<int>(max(0LL, ans));
    }

private:
    long long kadane(const vector<int>& a) {
        long long cur = a[0], best = a[0];
        for (size_t i = 1; i < a.size(); ++i) {
            cur = max((long long)a[i], cur + a[i]);
            best = max(best, cur);
        }
        return best;
    }

    long long kadaneTwoCopies(const vector<int>& arr) {
        vector<int> doubleArr(arr);
        doubleArr.insert(doubleArr.end(), arr.begin(), arr.end());
        return kadane(doubleArr);
    }
};
```

---

## 4. The Blog Post

> **Title**: *K‚ÄëConcatenation Maximum Sum ‚Äì A Deep Dive into Good, Bad, and Ugly Solutions*  
> **Meta Description**: ‚ÄúLearn how to solve LeetCode 1470 in Java, Python, and C++. Understand Kadane‚Äôs algorithm, handle big k, and avoid common pitfalls. Read the full guide now!‚Äù

### 4.1 Introduction

When you sit down to solve **LeetCode 1470 ‚Äì K‚ÄëConcatenation Maximum Sum**, a wave of common mistakes often washes over your head:

- ‚ÄúJust concatenate `k` copies and run Kadane.‚Äù  
- ‚ÄúUse dynamic programming over `k` states.‚Äù  
- ‚ÄúDon‚Äôt forget the modulo 1‚ÄØ000‚ÄØ000‚ÄØ007.‚Äù  

Each of these approaches can lead to *TLE*, *MLE*, or even subtle integer‚Äëoverflow bugs. In this article, we‚Äôll dissect the *good*, *bad*, and *ugly* ways to tackle the problem, provide ready‚Äëto‚Äëcopy code for three popular languages, and show you why the linear‚Äëtime solution wins every time.

---

### 4.2 What the Problem Really Asks

> **K‚ÄëConcatenation** ‚Äì create a new array by appending `arr` to itself `k` times.  
> **Goal** ‚Äì the maximum sum of a contiguous sub‚Äëarray in that new array, modulo `10‚Åπ‚ÄØ+‚ÄØ7`.  
> **Edge case** ‚Äì if the maximum sum is negative, return `0`.

The constraints are huge (arr length up to 10‚Åµ, k up to 10‚Åµ). A na√Øve O(k‚ÄØ¬∑‚ÄØn) solution will never pass.

---

### 4.3 Good: The Optimal Kadane‚ÄëBased Strategy

| Step | What it does | Why it works |
|------|--------------|--------------|
| **Kadane on single copy** | Gives the best sub‚Äëarray that stays inside one copy. | Classic linear‚Äëtime max‚Äësub‚Äëarray. |
| **Kadane on two copies** | Captures the best sub‚Äëarray that *crosses* the boundary between two copies. | The only place a sub‚Äëarray can span more than one copy is at the junction. |
| **Use the total sum** | If `sum(arr) > 0`, every middle copy contributes its full sum to any cross‚Äëboundary sub‚Äëarray. | All interior copies add `total` each; the remaining two copies handle the crossing part. |
| **Formula** | `answer = bestTwo + (k-2) * total` (when `k>2` and `total>0`). | Linear, constant space. |
| **Modulo & final clip** | `max(0, answer) % MOD`. | Handles negative answers and keeps the result in bounds. |

*The key is realizing that after the first two copies, we never need to materialize the entire `k`‚Äëlength array.*

---

### 4.4 Bad: The ‚ÄúLet‚Äôs Just Duplicate‚Äù Approach

A tempting but *bad* solution is:

```python
double_arr = arr * 2
full_arr   = arr * k          # O(k¬∑n) memory!
ans        = max_subarray(full_arr)
```

Problems:

1. **Memory explosion** ‚Äì `k` can be 10‚Åµ, so `arr * k` can be 10¬π‚Å∞ elements.  
2. **Time blow‚Äëup** ‚Äì Kadane would run O(k¬∑n).  
3. **Overflow** ‚Äì Python‚Äôs ints are fine, but C++/Java may overflow 32‚Äëbit ints before the modulo.  

Because of these reasons, this approach fails the platform‚Äôs ‚ÄúTime Limit Exceeded‚Äù or ‚ÄúMemory Limit Exceeded‚Äù tests.

---

### 4.5 Ugly: Mixing Prefix/Surfix Sums with Kadane, Wrong Modulo, Negative Handling

The **ugly** pattern looks like:

```java
long ans = kadaneTwoCopies(arr) + (k-2) * total;
ans = ans % MOD;           // Wrong! Should do modulo *after* clipping negative
int result = (int)Math.max(0, ans);
```

Why this is ugly:

- **Modulo order** ‚Äì The LeetCode statement demands that you apply `max(0, answer)` *before* modulo. Modding a negative number keeps the negative sign, which violates the ‚Äúreturn 0 if negative‚Äù rule.  
- **Overflow** ‚Äì `total` can be as large as `10‚Åµ * 10‚Åπ` ‚Üí needs 64‚Äëbit integers.  
- **Readability** ‚Äì Mixing 3 distinct ‚ÄúKadane‚Äù variants in the same file makes the logic hard to audit.

---

### 4.6 Production‚ÄëReady Tips

| Tip | Why |
|-----|-----|
| Use **long / 64‚Äëbit** for intermediate sums. | Prevents overflow before applying modulo. |
| **Reuse Kadane** ‚Äì write a single helper that can accept any array. | Keeps code DRY and easy to test. |
| **Modulo only once** ‚Äì after the entire calculation. | Avoids unnecessary `%` calls that waste time. |
| **Clamp to zero early** ‚Äì `max(0, answer)` before the final modulo. | Simplifies the logic for negative cases. |
| Write clear comments that explain ‚Äúcross‚Äëboundary‚Äù vs ‚Äúfull‚Äësum middle copies‚Äù. | Future‚Äëproofs the code and makes peer reviews faster. |

---

## 5. Why This Article Helps You Rank

- **Keyword density**: ‚ÄúK‚Äëconcatenation maximum sum‚Äù, ‚ÄúKadane algorithm‚Äù, ‚ÄúLeetCode 1470 solution‚Äù, ‚ÄúJava Kadane‚Äù, ‚ÄúPython Kadane‚Äù, ‚ÄúC++ LeetCode solution‚Äù.  
- **Structured headings (H2, H3)** for SEO crawlers.  
- **Meta tags** with a concise description and keyword‚Äërich title.  
- **Code snippets** wrapped in `<details>` tags to satisfy both humans and bots.  

With these optimizations, the article will appear near the top of Google‚Äôs search results for any candidate searching for a clean LeetCode solution or interview prep tips.

---

## 5. Summary

1. The **optimal** way to solve K‚ÄëConcatenation Maximum Sum is a single pass Kadane plus a careful handling of the middle copies when the total sum is positive.  
2. The three language implementations above run in **O(n)** time and **O(1)** extra space.  
3. Avoid the **ugly** pitfalls: never materialize all `k` copies, always handle modulo after clipping negative answers, and use 64‚Äëbit integers to keep sums safe.  

Happy coding, and may your sub‚Äëarray sums always stay on the high side! üéâ