---
title: LeetCode 2262. Total Appeal of A String - 
description: Placeholder
date: 2025-09-21
categories: []
author: moses
tags: []
hideToc: true
---
        ## üéØ Problem Recap ‚Äì LeetCode 2262: *Total Appeal of a String*  

| | |
|---|---|
| **Difficulty** | Hard |
| **Type** | String, Math, Dynamic Programming |
| **Runtime Constraints** | `1‚ÄØ‚â§‚ÄØs.length‚ÄØ‚â§‚ÄØ10‚Åµ` |
| **Language Support** | Java, Python, C++ |

**Definition**

*The **appeal** of a string* = the number of **distinct** characters it contains.  
Given a string `s`, return the **sum of appeals** of **every** possible contiguous substring of `s`.

---

## 1Ô∏è‚É£ Na√Øve Brute‚ÄëForce (and why it‚Äôs a *big no‚Äëno*)

1. Enumerate all `O(n¬≤)` substrings.  
2. For each substring, build a `Set` of its characters ‚Üí `O(length)` work.  
3. Sum the sizes.

**Time** ‚Äì `O(n¬≥)` in the worst case (e.g., all characters are the same).  
**Space** ‚Äì `O(1)` (besides temporary set).  

> **Bad** ‚Äì This blows up quickly. Even `n = 10‚Å¥` would already be infeasible.

---

## 2Ô∏è‚É£ Insight: Contribution of a Character

Think of each character `c` independently.  
How many substrings contain that particular occurrence of `c`?  
If we can sum these counts over all occurrences, we get the answer.

### Observation

For an occurrence at index `i` (0‚Äëbased):

- Let `last[c]` be the index of the **previous** occurrence of the same character.  
  (If `c` hasn‚Äôt appeared yet, `last[c] = -1`.)  
- Any substring that ends at index `i` *and* starts **after** `last[c]` will contain this `c`.  

Number of such substrings  
```
(i - last[c])      // possible start positions
```

So the contribution of this occurrence to the final sum is  
```
(i - last[c]) * (n - i)
```
because the substring can end anywhere from `i` to `n‚Äë1`.

### Total Complexity

We traverse the string once, updating `last[26]` and adding the contribution for each character.  
Both **time** and **space** are linear/constant.

> **Good** ‚Äì `O(n)` time, `O(1)` space.  

---

## 3Ô∏è‚É£ Why a 26‚Äëloop per character is *Ugly*

A simpler DP solution keeps a running total of the last positions of each letter (`last[26]`) and adds them via an inner `for (int k=0;k<26;k++) total += i+1-last[k]`.  
That is **`O(26‚ÄØ¬∑‚ÄØn)`** ‚Äì still linear, but the factor 26 can dominate for very large `n`.  
Moreover, the code is harder to read and reason about.

---

## 4Ô∏è‚É£ Final Elegant O(n) Solution (Prev‚ÄëOccurrence trick)

A slightly different viewpoint is to maintain the **current appeal for all substrings that end at index `i`** (`cur`) and add that to the global result.

```
cur += (i + 1) - last[s[i]]         // new substrings that bring this char into the appeal
last[s[i]] = i + 1                  // +1 so we can start counting at 1 instead of 0
res += cur
```

Both variants produce the same result; we‚Äôll present both for clarity.

---

## 4Ô∏è‚É£ Code ‚Äì Three Languages

> **Tip** ‚Äì All codes are ready‚Äëto‚Äërun on LeetCode, CodeChef, HackerRank, etc.

### 4.1. Java¬†17

```java
// 2262. Total Appeal of a String ‚Äì Java
class Solution {
    public long appealSum(String s) {
        int n = s.length();
        int[] last = new int[26];          // last occurrence (+1). 0 means ‚Äúnever seen‚Äù.
        long res = 0, total = 0;

        for (int i = 0; i < n; i++) {
            int idx = s.charAt(i) - 'a';
            total += (i + 1) - last[idx];  // substrings that newly include this char
            last[idx] = i + 1;             // update to current position (+1)
            res += total;                  // all substrings ending at i
        }
        return res;
    }
}
```

### 4.2. Python‚ÄØ3.10+

```python
# 2262. Total Appeal of a String ‚Äì Python 3
from collections import defaultdict

class Solution:
    def appealSum(self, s: str) -> int:
        n = len(s)
        last = defaultdict(lambda: -1)
        res = 0

        for i, ch in enumerate(s):
            # (i - last[ch]) * (n - i)   ‚Äì contribution of this occurrence
            res += (i - last[ch]) * (n - i)
            last[ch] = i
        return res
```

### 4.3. C++17

```cpp
// 2262. Total Appeal of a String ‚Äì C++17
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    long long appealSum(string s) {
        int n = s.size();
        vector<int> last(26, -1);
        long long res = 0;
        for (int i = 0; i < n; ++i) {
            int idx = s[i] - 'a';
            res += 1LL * (i - last[idx]) * (n - i);
            last[idx] = i;
        }
        return res;
    }
};
```

All three codes run in **O(n)** time, **O(1)** auxiliary memory.

---

## 4Ô∏è‚É£ Edge‚ÄëCase Checklist

| Case | Expected Result | Why it matters |
|------|-----------------|----------------|
| All same letters, e.g. `"aaaa"` | `4*5/2 = 10` substrings, each appeal `1` ‚Üí sum `10` | ensures we treat duplicates correctly |
| All distinct, e.g. `"abcd"` | Appeal of each substring equals its length | tests the *max* appeal scenario |
| Empty string ‚Äì not allowed by constraints | N/A | |
| Single character, e.g. `"z"` | Appeal `1` | trivial base case |
| Max length `10‚Åµ` random string | Should finish <‚ÄØ0.5‚ÄØs on LeetCode | stress‚Äëtest |

---

## 5Ô∏è‚É£ Quick Test Harness (Python)

```python
def brute(s):
    n = len(s)
    ans = 0
    for i in range(n):
        seen = set()
        for j in range(i, n):
            seen.add(s[j])
            ans += len(seen)
    return ans

def test():
    import random, string
    for n in range(1, 50):
        for _ in range(100):
            s = ''.join(random.choice('abc') for _ in range(n))
            if brute(s) != Solution().appealSum(s):
                print('Mismatch', s, brute(s), Solution().appealSum(s))
                return
    print('All tests passed!')

if __name__ == "__main__":
    test()
```

---

## 6Ô∏è‚É£ Conclusion ‚Äì What Interviewers Want

- **Time‚Äëefficient**: `O(n)` solves the problem in sub‚Äësecond time even for `n=10‚Åµ`.  
- **Space‚Äëlight**: only a 26‚Äëelement array or dictionary.  
- **Mathematical elegance**: character‚Äëby‚Äëcharacter contribution avoids messy DP or loops.  

> **Good** ‚Äì Simple, linear, easy to reason about.  
> **Bad** ‚Äì Na√Øve set‚Äëbased or DP with a 26‚Äëloop per character ‚Äì both are unnecessary.  
> **Ugly** ‚Äì Over‚Äëengineering the solution or forgetting the +1 trick can lead to off‚Äëby‚Äëones.

---

## üìÑ SEO‚ÄëOptimized Blog Article

### Title
> **Master LeetCode 2262 ‚Äì Total Appeal of a String | Java, Python, C++ O(n) Solution**

### Meta Description
> Solve LeetCode 2262 *Total Appeal of a String* in linear time. Learn the character‚Äëcontribution trick with clear Java, Python, and C++ code. Perfect for interview prep!

---

## üöÄ Blog Post

### Introduction
Interviews love problems that disguise a simple pattern behind a daunting ‚ÄúHard‚Äù label. *Total Appeal of a String* is one such classic. Despite its `Hard` tag, the most efficient solution is a single‚Äëpass `O(n)` algorithm with `O(1)` memory. This post walks you through:

- Problem restatement
- Na√Øve pitfalls
- The **good** linear solution
- The **bad** quadratic/‚Äãcubic brute force
- The **ugly** DP version with a 26‚Äëloop
- Clean code snippets (Java, Python, C++)
- Complexity analysis
- Edge‚Äëcase discussion
- Quick test harness

---

### 1Ô∏è‚É£ Problem Statement

> **Appeal** = number of distinct characters in a string.  
> For every contiguous substring of `s`, compute its appeal and sum them all.

Example: `s = "aba"`  
Substrings ‚Üí `"a"`, `"ab"`, `"aba"`, `"b"`, `"ba"`, `"a"`  
Appeals ‚Üí 1,‚ÄØ2,‚ÄØ2,‚ÄØ1,‚ÄØ2,‚ÄØ1 ‚Üí **Total = 9**.

---

### 2Ô∏è‚É£ Na√Øve Approach ‚Äì The Big No‚ÄëNo

```text
for every i in [0,n):
  for every j in [i,n):
    build set of s[i..j]
    ans += size(set)
```

- **Time** `O(n¬≥)` ‚Üí impossible for `n=10‚Åµ`.  
- **Space** `O(1)` (ignoring the temporary set).  

This is the classic *exponential blow‚Äëup* you must avoid in interviews.

---

### 3Ô∏è‚É£ The ‚ÄúGood‚Äù Insight: Character Contribution

Consider each occurrence of a character separately.

1. `last[26]` holds the index of the last occurrence of each letter (`-1` if none).  
2. For the occurrence at index `i` of character `c`:
   - Substrings that **start after** `last[c]` and **end at or after** `i` contain this `c`.  
   - Number of starts: `i - last[c]`.  
   - Number of ends: `n - i`.  
3. Contribution: `(i - last[c]) * (n - i)`.

Add this for every index.  

**Result:** Linear scan, constant auxiliary space.

> **Why it‚Äôs *Good*** ‚Äì No nested loops, no expensive sets, just integer arithmetic.

---

### 4Ô∏è‚É£ The ‚ÄúUgly‚Äù DP with a 26‚Äëloop

A common DP pattern:

```text
total = 0
for each character:
    total += i - last[c]
    last[c] = i
```

Then, in every iteration, sum all `last` values via an inner `for (k=0;k<26;k++) total += last[k];`  
This is **`O(26‚ÄØ¬∑‚ÄØn)`**, still linear but the constant factor hurts readability and performance.

> **Ugly** ‚Äì Adds unnecessary loops and makes the logic harder to maintain.

---

### 5Ô∏è‚É£ Full Code Snippets

| Language | Code |
|----------|------|
| **Java** | <details><summary>Click to view</summary><pre>class Solution {<br>    public long appealSum(String s) {<br>        int n = s.length();<br>        int[] last = new int[26];<br>        long res = 0;<br>        for (int i = 0; i < n; ++i) {<br>            int idx = s.charAt(i) - 'a';<br>            res += 1L * (i - last[idx]) * (n - i);<br>            last[idx] = i;<br>        }<br>        return res;<br>    }<br>}<br></pre></details> |
| **Python** | <details><summary>Click to view</summary><pre>class Solution:<br>    def appealSum(self, s: str) -> int:<br>        n = len(s)<br>        last = defaultdict(lambda: -1)<br>        res = 0<br>        for i, ch in enumerate(s):<br>            res += (i - last[ch]) * (n - i)<br>            last[ch] = i<br>        return res</pre></details> |
| **C++** | <details><summary>Click to view</summary><pre>class Solution {<br>public:<br>    long long appealSum(string s) {<br>        int n = s.size();<br>        vector<int> last(26, -1);<br>        long long res = 0;<br>        for (int i = 0; i < n; ++i) {<br>            int idx = s[i] - 'a';<br>            res += 1LL * (i - last[idx]) * (n - i);<br>            last[idx] = i;<br>        }<br>        return res;<br>    }<br>};</pre></details> |

All codes compile on LeetCode, CodeChef, and other online judges.

---

### 6Ô∏è‚É£ Complexity Recap

- **Time**: `O(n)` (single pass).  
- **Space**: `O(1)` (26‚Äëelement array or dictionary).  
- **Numerical operations**: `1‚ÄØ√ó‚ÄØ10‚Å∂` multiplications and adds for `n=10‚Åµ` ‚Äì trivial on modern CPUs.

---

### 7Ô∏è‚É£ Testing ‚Äì Quick Python Script

```python
def brute(s):
    # O(n^3) brute force for small strings
    ...

def test():
    import random, string
    for n in range(1, 100):
        for _ in range(200):
            s = ''.join(random.choice('abcd') for _ in range(n))
            if brute(s) != Solution().appealSum(s):
                print('Fail', s, brute(s), Solution().appealSum(s))
                return
    print('All good!')

test()
```

Run this script locally to validate your implementation before submitting.

---

### 8Ô∏è‚É£ Final Takeaway

*Total Appeal of a String* teaches you that many ‚ÄúHard‚Äù problems boil down to a hidden linear trick. Master the character‚Äëcontribution pattern, and you‚Äôll answer confidently in Java, Python, or C++ during coding interviews. Remember: always look for a single‚Äëpass arithmetic solution before resorting to sets or nested loops.

---

### üìö Further Reading

- ‚ÄúCracking the Coding Interview‚Äù ‚Äì Character counting tricks
- ‚ÄúLeetCode Hard Problems‚Äù ‚Äì Pattern‚Äërecognition chapter
- ‚ÄúCoding Interview Prep‚Äù ‚Äì O(n) tricks collection

Happy coding! üöÄ

---

## üì£ Final Thought

Whether you‚Äôre tackling coding challenges or acing technical interviews, the lesson from *Total Appeal of a String* is clear: look for the **simple arithmetic pattern** behind a complex problem, keep your loops tight, and always aim for linear time. Happy interviewing!