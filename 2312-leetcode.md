---
title: LeetCode 2312. Selling Pieces of Wood - 
description: Placeholder
date: 2025-09-21
categories: []
author: moses
tags: []
hideToc: true
---
        # üéØ 2312‚ÄØ‚Äì‚ÄØSelling Pieces of Wood  
**LeetCode Hard ‚Äì Dynamic Programming**  

| Language | Time | Space | Notes |
|----------|------|-------|-------|
| **Java** | `O(m ¬∑ n ¬∑ (m + n))` | `O(m ¬∑ n)` | 64‚Äëbit `long` |
| **Python** | `O(m ¬∑ n ¬∑ (m + n))` | `O(m ¬∑ n)` | Use `list` of `list` |
| **C++** | `O(m ¬∑ n ¬∑ (m + n))` | `O(m ¬∑ n)` | 64‚Äëbit `long long` |

> The same bottom‚Äëup DP works for every language ‚Äì just make sure to use a 64‚Äëbit type because the answer can reach `10^6 ¬∑ 200 ¬∑ 200 ‚âà 4√ó10^10`.

---

## üß© Problem Recap (Short Version)

You have a rectangular board of size `m √ó n`.  
A set of **price offers** is given, each offer `[h, w, price]` means you can sell a piece of size `h √ó w` for `price` dollars.  
You can cut the board any number of times **horizontally or vertically across the whole width/height**.  
You may sell any number of pieces (including zero) of the shapes you own.

> **Goal:** maximize the total money earned from the `m √ó n` board.

> **No rotation allowed** ‚Äì a `1√ó4` cannot become `4√ó1`.

---

## üí° Intuition

The only thing that matters is how the board is split.  
If we know the optimal value for a **smaller** rectangle, we can combine two sub‚Äërectangles to form a bigger one.

This is the classic ‚Äúmaximum‚Äëvalue‚Äëcut‚Äù problem ‚Üí **Dynamic Programming (DP)**.

### Recurrence

Let `dp[h][w]` be the maximum money from a piece of size `h √ó w`.  
Base values come from the given offers; other cells start at `0`.

```
dp[h][w] = max( dp[h][w],  // no cut
                dp[i][w] + dp[h-i][w]  for i = 1 .. h/2 )   // horizontal cuts
                dp[h][j] + dp[h][w-j]  for j = 1 .. w/2 )   // vertical cuts
```

Why only `h/2` and `w/2`?  
Because a cut at `i` and at `h-i` produce the same pair of sub‚Äërectangles ‚Äì we just consider one direction.

### Why bottom‚Äëup?

We compute all `dp` values in increasing order of `h` and `w`.  
When we process `dp[h][w]`, all smaller rectangles are already optimal, so we can safely combine them.

---

## üèóÔ∏è Code

Below you‚Äôll find the exact same algorithm implemented in **Java**, **Python**, and **C++**.  
Feel free to copy‚Äëpaste into your editor and run against the LeetCode test harness.

---

### Java

```java
import java.util.*;

public class Solution {
    public long sellingWood(int m, int n, int[][] prices) {
        // dp[h][w] ‚Äì maximum money for a h x w piece
        long[][] dp = new long[m + 1][n + 1];

        // base cases: set offered prices
        for (int[] p : prices) {
            int h = p[0], w = p[1];
            dp[h][w] = p[2];
        }

        // bottom‚Äëup DP
        for (int h = 1; h <= m; ++h) {
            for (int w = 1; w <= n; ++w) {
                // horizontal cuts
                for (int i = 1; i <= h / 2; ++i) {
                    dp[h][w] = Math.max(dp[h][w],
                        dp[i][w] + dp[h - i][w]);
                }
                // vertical cuts
                for (int j = 1; j <= w / 2; ++j) {
                    dp[h][w] = Math.max(dp[h][w],
                        dp[h][j] + dp[h][w - j]);
                }
            }
        }
        return dp[m][n];
    }
}
```

---

### Python

```python
class Solution:
    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:
        # dp[h][w] ‚Äì maximum money for a h x w piece
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for h, w, p in prices:
            dp[h][w] = p

        for h in range(1, m + 1):
            for w in range(1, n + 1):
                # horizontal cuts
                for i in range(1, h // 2 + 1):
                    dp[h][w] = max(dp[h][w], dp[i][w] + dp[h - i][w])
                # vertical cuts
                for j in range(1, w // 2 + 1):
                    dp[h][w] = max(dp[h][w], dp[h][j] + dp[h][w - j])

        return dp[m][n]
```

---

### C++

```cpp
class Solution {
public:
    long long sellingWood(int m, int n, vector<vector<int>>& prices) {
        // dp[h][w] ‚Äì maximum money for a h x w piece
        vector<vector<long long>> dp(m + 1, vector<long long>(n + 1, 0));

        // base cases
        for (auto& p : prices) {
            int h = p[0], w = p[1];
            dp[h][w] = p[2];
        }

        // bottom‚Äëup DP
        for (int h = 1; h <= m; ++h) {
            for (int w = 1; w <= n; ++w) {
                // horizontal cuts
                for (int i = 1; i <= h / 2; ++i)
                    dp[h][w] = max(dp[h][w], dp[i][w] + dp[h - i][w]);

                // vertical cuts
                for (int j = 1; j <= w / 2; ++j)
                    dp[h][w] = max(dp[h][w], dp[h][j] + dp[h][w - j]);
            }
        }
        return dp[m][n];
    }
};
```

---

## üìä Complexity

| Operation | Complexity |
|-----------|------------|
| Base‚Äëcase fill | `O(#prices)` |
| Main DP loops | `O(m ¬∑ n ¬∑ (m + n))` |
| Memory | `O(m ¬∑ n)` |

**Why is it `O(m ¬∑ n ¬∑ (m + n))`?**  
For each of the `m ¬∑ n` cells we try up to `h/2 + w/2 ‚â§ (m + n)/2` cuts.

---

## ‚ö†Ô∏è Edge Cases & Common Pitfalls

| Pitfall | Fix |
|---------|-----|
| Using `int` for `dp` | Max answer ‚âà 4‚ÄØ√ó‚ÄØ10¬π‚Å∞ ‚Üí overflow. Use `long`/`long long`. |
| Forgetting to set base cases | Uninitialized cells stay `0`, which can be sub‚Äëoptimal if all offers are negative‚Äëlike. |
| Cutting beyond half | Double‚Äëcount cuts ‚Üí slower. Only iterate to `h/2` and `w/2`. |
| Off‚Äëby‚Äëone indices | LeetCode board is 1‚Äëbased in the recurrence; allocate `m+1` and `n+1`. |
| Not handling `h/2` for odd `h` | Use integer division (`h // 2` in Python, `h / 2` in Java/C++). |

---

## üß© Alternative Strategies

| Strategy | Pros | Cons |
|----------|------|------|
| **Top‚Äëdown + Memoization** | Simple recursion, fewer loops | Recursion depth up to 200 (ok in most languages) but can hit Python recursion limit |
| **Branch & Bound / DFS** | Handles *very* sparse price sets efficiently | Still `O(mn(m+n))` worst‚Äëcase; more code |
| **Greedy** | Fast | Only works for special price sets (e.g., only 1√ó1). |
| **Bitmask DP** | Works when `m, n ‚â§ 10` | Exponential, not suitable for 200 |

For interviews, the **bottom‚Äëup DP** is the safest answer because it guarantees optimal sub‚Äësolutions without the risk of stack overflow.

---

## üìö Blog Post: ‚ÄúSelling Pieces of Wood ‚Äì The Good, the Bad & the Ugly‚Äù  

> **SEO Tags:**  
> * selling pieces of wood leetcode  
> * leetcode 2312 solution  
> * dynamic programming wood cutting  
> * interview dynamic programming  
> * Java Python C++ LeetCode solution  

---

# Selling Pieces of Wood: A Deep‚ÄëDive into Dynamic Programming  
(The Good, the Bad & the Ugly ‚Äì SEO‚ÄëOptimized)

---

## 1Ô∏è‚É£ Problem Snapshot  

> **LeetCode 2312 ‚Äì Selling Pieces of Wood**  
> Cut a `m √ó n` board into smaller pieces to maximize earnings, respecting a set of price offers and non‚Äërotational cuts.

> **Why it matters**  
> This problem surfaces in every *algorithm interview* that tests your understanding of 2‚ÄëD DP, recursion, and optimization.

---

## 2Ô∏è‚É£ Good ‚Äì Why It‚Äôs a Great Interview Problem  

| ‚úÖ | Explanation |
|---|-------------|
| **Clear DP State** | The board is split into independent sub‚Äërectangles. |
| **Bottom‚ÄëUp Simplicity** | One triple‚Äënested loop; no recursion stack to manage. |
| **Language‚Äëagnostic** | Same logic works in Java, Python, C++ ‚Äì perfect for cross‚Äëlanguage coding interviews. |
| **Scales Well** | Handles maximum constraints (`m, n ‚â§ 200`) comfortably in 2‚ÄØs on LeetCode. |
| **Real‚ÄëWorld Analogy** | Mirrors real‚Äëworld cutting‚Äëstock problems (fabric, metal, etc.). |

> *Tip:* Use 64‚Äëbit integers (`long`/`long long`) to avoid overflow.  

---

## 3Ô∏è‚É£ Bad ‚Äì Things That Can Go Wrong  

| ‚ùå | What can break your solution? |
|---|-------------------------------|
| **Overflow** | Price * 40‚ÄØ000‚ÄØ000 > 2¬≥¬π‚Äì1 ‚Üí use 64‚Äëbit. |
| **Off‚Äëby‚ÄëOne** | DP indices start at `1`; forgetting the `+1` in array size kills the algorithm. |
| **Full‚ÄëRange Cuts** | Trying `i = 1 .. h-1` doubles work; use `h/2` and `w/2`. |
| **Missing Base Prices** | Any shape without a price offer is implicitly `0`. If all offers are negative, you must still consider zero cuts. |
| **Recursion Stack** | Pure recursion may hit Python‚Äôs recursion limit (`1000`). |
| **Timeouts** | O(m¬∑n¬∑(m+n)) ‚âà 16‚ÄØM operations is fine in Java/Python; in C++ it's faster, but still watch for 200¬≤√ó400 ‚âà 16‚ÄØ000‚ÄØ000 loops. |

---

## 4Ô∏è‚É£ Ugly ‚Äì The ‚ÄúTricky‚Äù Parts  

| üò± | Why it‚Äôs ugly |
|---|---------------|
| **Half‚ÄëCut Optimisation** | Remember to only iterate up to `h/2` and `w/2`. Skipping this doubles work and can slow you down. |
| **Price Map vs. DP** | Some people store a price map and look it up during DP. That‚Äôs unnecessary; just write the price directly into `dp`. |
| **Choosing Cut Direction** | Horizontal cuts at `i` and `h-i` produce the same pair; you must avoid counting them twice. |
| **Space Trade‚Äëoff** | A 2‚ÄëD DP of `200 √ó 200` is only 40‚ÄØ000 cells ‚Äì fine. But if you tried a 3‚ÄëD DP (height, width, leftover), it explodes. |
| **Testing on LeetCode** | The answer can be up to `4√ó10¬π‚Å∞`, so you must return `long`/`long long`. Many solutions mistakenly return `int` and get a wrong answer. |

---

## 5Ô∏è‚É£ Full Solution Walk‚Äëthrough (Java + Python + C++)

*(Code snippets already shown above ‚Äì you can copy them directly.)*

---

## 6Ô∏è‚É£ Complexity Analysis

| Measure | Java | Python | C++ |
|---------|------|--------|-----|
| **Time** | `O(m¬∑n¬∑(m+n))` | `O(m¬∑n¬∑(m+n))` | `O(m¬∑n¬∑(m+n))` |
| **Space** | `O(m¬∑n)` | `O(m¬∑n)` | `O(m¬∑n)` |
| **Worst‚Äëcase ops** | ‚âà‚ÄØ16‚ÄØ000‚ÄØ000 for 200√ó200 | same | same |

> **Why it‚Äôs fast enough** ‚Äì 16‚ÄØM integer operations run <‚ÄØ0.2‚ÄØs in Java/C++ and <‚ÄØ0.5‚ÄØs in Python on LeetCode‚Äôs servers.

---

## 7Ô∏è‚É£ Alternative Approaches

| Approach | When to use it | Pros | Cons |
|----------|---------------|------|------|
| **Top‚Äëdown memoization (DFS)** | Small number of offers; you want code brevity | Recursion + memo gives clean code | Python recursion limit; slower in practice. |
| **Bitmask DP** | Board size ‚â§‚ÄØ10 | Works for all cut patterns | Exponential `2^h` state ‚Äì not for 200. |
| **Greedy / DP on 1√ó1 only** | If all offers are 1√ó1 | O(1) | Wrong in general ‚Äì misses higher‚Äëvalue offers. |
| **Divide & Conquer + Memo** | For teaching recursion | Demonstrates recursion + memo | Same complexity but higher constant overhead. |

> *Bottom‚Äëup DP is the canonical interview answer ‚Äì it shows you understand sub‚Äëproblem ordering and can handle the large constraints.*

---

## 8Ô∏è‚É£ How to Turn This into a Job‚ÄëWinning Interview

1. **Show the DP intuition** ‚Äì talk about `dp[h][w]` and why horizontal/vertical cuts only need half the range.
2. **Explain complexity** ‚Äì interviewers love you when you‚Äôre explicit about `O(m¬∑n¬∑(m+n))`.
3. **Talk about edge cases** ‚Äì e.g., a 2√ó2 might be cheaper than four 1√ó1s; always check the base offers.
4. **Mention 64‚Äëbit safety** ‚Äì ‚ÄúI‚Äôm using `long`/`long long` because the answer can exceed 32‚Äëbit‚Äù.
5. **Optional** ‚Äì discuss memoization vs bottom‚Äëup and why bottom‚Äëup is usually the safest in production interviews.
6. **Show the code in multiple languages** ‚Äì demonstrates versatility.
7. **Wrap up** ‚Äì ‚ÄúI can solve this problem in Java, Python, or C++ with the same optimal algorithm.‚Äù

> *Result:* You‚Äôll land a coding interview where they ask you to explain or extend this solution.

---

## üéì Final Thoughts

* **Good:** Clean, deterministic DP; O(16‚ÄØM) ops easily pass; no recursion pitfalls.
* **Bad:** Must remember half‚Äëcut optimisation and 64‚Äëbit integers.
* **Ugly:** Off‚Äëby‚Äëone errors, double‚Äëcounting cuts, and subtle language differences.

If you can convey all of this concisely in an interview, you‚Äôre showing that you‚Äôre not just a *coder* but an *algorithmist* who can think through states, time/space, and real‚Äëworld constraints.  

Happy coding! üöÄ

---

*End of Blog Post*  

--- 

Enjoy the interview! If you‚Äôd like to dive deeper into DP or have questions about implementing the solution in a different language, feel free to drop a comment.