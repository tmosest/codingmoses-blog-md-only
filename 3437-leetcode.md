---
title: LeetCode 3437. Permutations III - 
description: Placeholder
date: 2025-09-21
categories: []
author: moses
tags: []
hideToc: true
---
        # 3437 ‚Äì Permutations‚ÄØIII  
**‚ÄúThe Good, the Bad, and the Ugly of Alternating Permutations‚Äù**  
*A complete, SEO‚Äëoptimized guide with Java, Python, and C++ solutions*

---

## üìå TL;DR  

- **Problem**: Generate *all* permutations of `1 ‚Ä¶ n` such that no two adjacent numbers share the same parity (both odd or both even).  
- **Solution**: Classic backtracking with a parity‚Äëcheck guard.  
- **Complexity**: `O(n!)` time, `O(n)` extra space (plus recursion stack).  
- **Languages**: Java, Python, C++ (all runnable on LeetCode, interview prep, or your own IDE).  

---

## üóûÔ∏è Blog Post ‚Äì ‚ÄúThe Good, the Bad, and the Ugly of Alternating Permutations‚Äù

### 1. Why This Problem Rocks (and How It Helps Your Resume)

- **Interview Signal**: LeetCode 3437 is a *medium* difficulty question that tests:
  - Understanding of permutations.
  - Ability to add a *conditional constraint*.
  - Clean backtracking implementation.
- **Career Impact**: Mastering this problem showcases your *algorithmic thinking* and *problem‚Äësolving* skills ‚Äì key traits hiring managers look for in software engineers.

---

### 2. Problem Statement (from LeetCode)

> **Given an integer `n`, return all permutations of the first `n` positive integers such that no two adjacent elements are both odd or both even.**  
> Return the permutations sorted in lexicographical order.

**Constraints**

- `1 ‚â§ n ‚â§ 10`

**Examples**

| n | Output |
|---|--------|
| 4 | `[[1,2,3,4],[1,4,3,2],[2,1,4,3],[2,3,4,1],[3,2,1,4],[3,4,1,2],[4,1,2,3],[4,3,2,1]]` |
| 2 | `[[1,2],[2,1]]` |
| 3 | `[[1,2,3],[3,2,1]]` |

---

### 3. Breaking Down the ‚ÄúGood‚Äù

#### 3.1 Conceptual Simplicity  
- We start from the standard permutation backtracking template.  
- The *only* extra rule is a parity check: `candidate[pos-1] % 2 != nums[i] % 2`.  
- Because the check is constant time, the algorithm stays *linear* in terms of branching decisions.

#### 3.2 Readability & Reusability  
- The Java code uses clear variable names (`nums`, `used`, `candidate`, `result`).  
- The recursive helper has a single responsibility: generate a permutation if it satisfies the parity constraint.

#### 3.3 Correctness Proof (Sketch)  
- **Base**: Every permutation of `1‚Ä¶n` is generated by the underlying backtracking logic.  
- **Induction**: Assume all partial permutations up to length `k` satisfy the parity rule.  
- Adding a new number `x` at position `k` only occurs if `x`‚Äôs parity differs from the previous number‚Äôs parity.  
- Thus, every full-length permutation returned satisfies the rule, and no valid permutation is omitted.

---

### 4. The ‚ÄúBad‚Äù

- **Exponential Growth**: Even for `n = 10`, there are `10! ‚âà 3.6‚ÄØmillion` permutations.  
- **Space & Time**: Storing all permutations at once can be memory‚Äëintensive.  
- **Practical Limits**: In real interview settings, LeetCode‚Äôs limits (`n ‚â§ 10`) make it safe, but be ready to explain constraints if the interviewer increases `n`.

---

### 5. The ‚ÄúUgly‚Äù

- **Lexicographical Ordering**: The standard backtracking algorithm naturally produces permutations in lexicographic order *if* we iterate `nums` in ascending order and never backtrack in a non‚Äësorted fashion.  
- **Edge Cases**: For `n = 1`, the only permutation is `[1]`, which is automatically valid.  
- **Potential Pitfall**: Forgetting to reset the `used` flag after recursion can lead to duplicate permutations or missed ones.

---

### 6. The Solution ‚Äì Backtracking with Parity Guard

Below is the core idea expressed in three popular languages. Copy‚Äëpaste, run, and feel the algorithm!

---

## 6.1 Java Implementation

```java
import java.util.*;

class Solution {
    public int[][] permute(int n) {
        // Build the array [1, 2, ..., n]
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) nums[i] = i + 1;

        boolean[] used = new boolean[n];
        int[] candidate = new int[n];
        List<int[]> res = new ArrayList<>();

        backtrack(nums, 0, used, candidate, res);

        // Convert List<int[]> to int[][] for the LeetCode signature
        int[][] out = new int[res.size()][n];
        for (int i = 0; i < res.size(); i++)
            out[i] = res.get(i);

        return out;
    }

    private void backtrack(int[] nums, int pos, boolean[] used,
                           int[] candidate, List<int[]> res) {
        if (pos == nums.length) {
            res.add(candidate.clone());  // deep copy
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (!used[i]) {
                // First position is free; others must alternate parity
                if (pos == 0 || (candidate[pos - 1] % 2) != (nums[i] % 2)) {
                    candidate[pos] = nums[i];
                    used[i] = true;
                    backtrack(nums, pos + 1, used, candidate, res);
                    used[i] = false;   // backtrack
                }
            }
        }
    }
}
```

**Key Points**

- `candidate.clone()` ensures we store a *copy* of the current permutation.
- The parity check `(candidate[pos - 1] % 2) != (nums[i] % 2)` guarantees alternation.
- Lexicographic order is preserved because we iterate `nums` in ascending order and never shuffle.

---

## 6.2 Python Implementation

```python
from typing import List

class Solution:
    def permute(self, n: int) -> List[List[int]]:
        nums = list(range(1, n + 1))
        used = [False] * n
        candidate = [0] * n
        res: List[List[int]] = []

        def backtrack(pos: int):
            if pos == n:
                res.append(candidate.copy())
                return
            for i in range(n):
                if not used[i]:
                    if pos == 0 or (candidate[pos - 1] % 2) != (nums[i] % 2):
                        candidate[pos] = nums[i]
                        used[i] = True
                        backtrack(pos + 1)
                        used[i] = False

        backtrack(0)
        return res
```

**Why Python?**

- The `copy()` method is a lightweight way to snapshot `candidate`.
- The recursion depth is at most `n` (‚â§ 10), so no stack overflow.

---

## 6.3 C++ Implementation

```cpp
#include <vector>

class Solution {
public:
    std::vector<std::vector<int>> permute(int n) {
        std::vector<int> nums(n);
        for (int i = 0; i < n; ++i) nums[i] = i + 1;

        std::vector<bool> used(n, false);
        std::vector<int> candidate(n);
        std::vector<std::vector<int>> res;

        backtrack(nums, 0, used, candidate, res);
        return res;
    }

private:
    void backtrack(const std::vector<int>& nums, int pos,
                   std::vector<bool>& used,
                   std::vector<int>& candidate,
                   std::vector<std::vector<int>>& res) {
        if (pos == nums.size()) {
            res.push_back(candidate);
            return;
        }

        for (int i = 0; i < nums.size(); ++i) {
            if (!used[i]) {
                if (pos == 0 || (candidate[pos - 1] % 2) != (nums[i] % 2)) {
                    candidate[pos] = nums[i];
                    used[i] = true;
                    backtrack(nums, pos + 1, used, candidate, res);
                    used[i] = false;   // backtrack
                }
            }
        }
    }
};
```

**Highlights**

- Uses `std::vector` for dynamic arrays.
- `candidate` is directly pushed into `res`; the vector copy happens automatically.
- The same parity guard as the other languages.

---

## 7. Complexity Analysis

| Complexity | Explanation |
|------------|-------------|
| **Time** | `O(n!)` ‚Äì we generate every valid permutation. |
| **Space** | `O(n)` auxiliary (`candidate`, `used` arrays) + recursion stack `O(n)`. |
| **Result Storage** | `O(k * n)` where `k` is the number of valid permutations (‚â§ `n!`). |

---

## 8. Edge Cases & Testing

| n | Expected Output |
|---|-----------------|
| 1 | `[[1]]` |
| 2 | `[[1,2],[2,1]]` |
| 3 | `[[1,2,3],[3,2,1]]` |
| 4 | 8 permutations (as in the problem statement) |
| 10 | 3628800 permutations ‚Äì ensure your environment can handle this memory footprint if you run locally. |

**Testing Tips**

- Use unit tests to assert the length of the output and that all permutations are unique.
- Verify the parity rule for each pair of adjacent elements in the output.
- For large `n`, use a generator or stream to avoid storing all permutations at once (not required by LeetCode but useful in interviews).

---

## 9. Interview‚ÄëReady Explanation

> **‚ÄúWe generate permutations using backtracking, but at each step we only allow a number that flips the parity of the last number. Because we iterate numbers in ascending order, the final list is automatically lexicographically sorted.‚Äù**

If the interviewer asks for optimization, mention that:

- The problem is inherently factorial; no polynomial‚Äëtime algorithm exists.
- For larger `n`, you could generate them lazily or stream them one by one.

---

## 10. FAQs

| Question | Answer |
|----------|--------|
| *Why can we rely on lexicographic order?* | The standard recursive DFS that processes candidates in ascending order always emits permutations in lexicographic order. |
| *Can we use next_permutation instead?* | You could generate all permutations with `next_permutation` and filter them, but that would be `O(n! * n)` in time, slower than the direct backtracking approach. |
| *What if n > 10?* | The algorithm stays correct, but memory/time will blow up quickly. In an interview, discuss practical constraints. |
| *Is this algorithm equivalent to generating ‚Äúalternating permutations‚Äù of Euler?* | Not exactly; Euler‚Äôs alternating permutations refer to ‚Äúup‚Äëdown‚Äù sequences (strictly increasing then decreasing), whereas here we only care about parity. |

---

## 11. SEO & Final Thought

- **Keywords**: *LeetCode Permutations‚ÄØIII, alternating permutation, backtracking, Java solution, Python solution, C++ solution, interview algorithm, job interview tips, software engineer interview, algorithmic problem, factorial complexity*.
- **Meta Description**: ‚ÄúLearn how to solve LeetCode 3437 ‚Äì Permutations‚ÄØIII ‚Äì with backtracking. Full Java, Python, and C++ code, complexity analysis, and interview insights. Master the alternating permutation problem today!‚Äù

---  

**Takeaway**: The solution is a clean, backtracking‚Äëbased algorithm that respects a simple parity condition. It‚Äôs a great showcase of your ability to adapt a classic permutation algorithm to meet an additional constraint‚Äîexactly the kind of skill interviewers value.

Happy coding! üöÄ