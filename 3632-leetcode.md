---
title: LeetCode 3632. Subarrays with XOR at Least K - 
description: Placeholder
date: 2025-09-21
categories: []
author: moses
tags: []
hideToc: true
---
        ## üéØ Problem Overview ‚Äì LeetCode 3632: ‚ÄúSubarrays with XOR at Least‚ÄØK‚Äù

| ‚úÖ   | **Problem** | **Constraints** | **Goal** |
|------|-------------|-----------------|----------|
| **Hard** | Given an array `nums` (1‚ÄØ‚â§‚ÄØn‚ÄØ‚â§‚ÄØ10‚Åµ, 0‚ÄØ‚â§‚ÄØnums[i]‚ÄØ‚â§‚ÄØ10‚Åπ) and an integer `k` (0‚ÄØ‚â§‚ÄØk‚ÄØ‚â§‚ÄØ10‚Åπ), count how many **contiguous** sub‚Äëarrays have a **bitwise XOR** that is **‚â•‚ÄØk**. | `long` is required for the answer (n can be 10‚Åµ ‚Üí ~5√ó10‚Åπ sub‚Äëarrays). | Return the total number of valid sub‚Äëarrays. |

> **Example**  
> `nums = [3,1,2,3]`, `k = 2` ‚Üí answer: **6**.

---

## üìä The ‚ÄúGood, the Bad, and the Ugly‚Äù of the Solution

| Aspect | Good | Bad | Ugly |
|--------|------|-----|------|
| **Na√Øve O(n¬≤) double‚Äëloop** | Simple to code, works for tiny inputs. | 10‚Åµ¬≤ operations ‚Üí impossible. | 100‚ÄØ% TLE on LeetCode. |
| **Prefix XOR + Brute‚ÄëForce** | Reduce inner XOR to O(1) using prefix XOR. | Still O(n¬≤) for enumeration. | Still TLE. |
| **Binary Trie + Prefix XOR** | **O(n‚ÄØ¬∑‚ÄØW)** (W‚ÄØ=‚ÄØ32) ‚Üí ‚âà‚ÄØ3.2‚ÄØ√ó‚ÄØ10‚Å∂ ops. | Needs careful bit handling & memory. | Easy to bug‚Äëprove (off‚Äëby‚Äëone, overflow). |
| **Space** | O(n‚ÄØ¬∑‚ÄØW) for trie nodes (~3‚ÄØMB). | Acceptable. | Large memory if W too big. |

The binary‚Äëtrie approach is the **golden solution** that passes all tests, runs fast enough for job interviews, and demonstrates a deep understanding of bit manipulation and prefix sums.

---

## üß† Intuition & Algorithm

1. **Prefix XOR**:  
   `pref[i] = nums[0] ‚äï ‚Ä¶ ‚äï nums[i-1]`.  
   XOR of sub‚Äëarray `l ‚Ä¶ r` equals `pref[r+1] ‚äï pref[l]`.

2. **Counting Sub‚Äëarrays**:  
   For each `pref[r+1]` we need the number of previous prefixes `pref[l]` such that  
   `pref[r+1] ‚äï pref[l] ‚â• k`.

3. **Binary Trie**:  
   Store all previous prefixes in a trie where each node represents a bit (0 or 1).  
   Each node keeps a `cnt` of how many numbers go through that node.  
   While querying, we walk the trie from the most significant bit (31st) down to 0, deciding whether to:
   * take the opposite bit (ensures XOR‚ÄØ‚â•‚ÄØk at this bit level), or
   * stay on the same bit (continue checking lower bits).

4. **Complexities**:  
   *Time* ‚Äì O(n‚ÄØ¬∑‚ÄØ32) ‚âà O(n).  
   *Space* ‚Äì O(n‚ÄØ¬∑‚ÄØ32) for the trie nodes (‚â§‚ÄØ4‚ÄØ√ó‚ÄØn‚ÄØbytes ‚âà 4‚ÄØMB).

---

## üîß Implementation ‚Äì 3 Languages

### 1. Java

```java
import java.io.*;
import java.util.*;

public class Solution {
    /* ---------- Trie Node ---------- */
    private static class TrieNode {
        TrieNode[] child = new TrieNode[2];
        int count = 0;
    }

    /* ---------- Public API ---------- */
    public long countXorSubarrays(int[] nums, int k) {
        TrieNode root = new TrieNode();
        insert(root, 0);                 // empty prefix
        long result = 0;
        int prefix = 0;

        for (int num : nums) {
            prefix ^= num;
            result += query(root, prefix, k);
            insert(root, prefix);
        }
        return result;
    }

    /* ---------- Insert a number into the trie ---------- */
    private void insert(TrieNode root, int val) {
        TrieNode node = root;
        for (int i = 31; i >= 0; i--) {
            int bit = (val >> i) & 1;
            if (node.child[bit] == null) node.child[bit] = new TrieNode();
            node = node.child[bit];
            node.count++;
        }
    }

    /* ---------- Query: how many prefixes give XOR >= k ---------- */
    private long query(TrieNode root, int prefix, int k) {
        TrieNode node = root;
        long count = 0;
        for (int i = 31; i >= 0 && node != null; i--) {
            int pBit = (prefix >> i) & 1;
            int kBit = (k >> i) & 1;

            if (kBit == 1) {                 // need opposite bit to keep XOR >= k
                node = node.child[1 - pBit];
            } else {                         // if opposite bit exists, all of them qualify
                if (node.child[1 - pBit] != null)
                    count += node.child[1 - pBit].count;
                node = node.child[pBit];
            }
        }
        if (node != null) count += node.count;   // all remaining numbers are valid
        return count;
    }

    /* ---------- Driver for quick manual testing ---------- */
    public static void main(String[] args) throws Exception {
        Solution sol = new Solution();
        System.out.println(sol.countXorSubarrays(new int[]{3,1,2,3}, 2));   // 6
        System.out.println(sol.countXorSubarrays(new int[]{0,0,0}, 0));     // 6
    }
}
```

> **Why a `long`?**  
> The number of sub‚Äëarrays can reach ~5‚ÄØ√ó‚ÄØ10‚Åπ, which exceeds `int`.  
> All counts in the trie are stored as `int` because at most `n` prefixes pass through a node.  

---

### 2. Python

```python
class TrieNode:
    __slots__ = ("child", "count")
    def __init__(self):
        self.child = [None, None]
        self.count = 0

class Solution:
    def countXorSubarrays(self, nums: list[int], k: int) -> int:
        root = TrieNode()
        self._insert(root, 0)          # empty prefix
        res = 0
        pref = 0

        for num in nums:
            pref ^= num
            res += self._query(root, pref, k)
            self._insert(root, pref)

        return res

    def _insert(self, root: TrieNode, val: int) -> None:
        node = root
        for i in range(31, -1, -1):
            bit = (val >> i) & 1
            if node.child[bit] is None:
                node.child[bit] = TrieNode()
            node = node.child[bit]
            node.count += 1

    def _query(self, root: TrieNode, pref: int, k: int) -> int:
        node = root
        ans = 0
        for i in range(31, -1, -1):
            if node is None:
                break
            p_bit = (pref >> i) & 1
            k_bit = (k >> i) & 1
            if k_bit == 1:
                node = node.child[1 - p_bit]          # must take opposite bit
            else:
                # all numbers with opposite bit already satisfy >=k
                if node.child[1 - p_bit]:
                    ans += node.child[1 - p_bit].count
                node = node.child[p_bit]
        if node:
            ans += node.count
        return ans

# ---------- Quick manual test ----------
if __name__ == "__main__":
    sol = Solution()
    print(sol.countXorSubarrays([3,1,2,3], 2))   # 6
    print(sol.countXorSubarrays([0,0,0], 0))     # 6
```

> **Python tips**:  
> *Use `__slots__` to reduce memory overhead of many trie nodes.*  
> *The bit‚Äëloop runs from 31 down to 0 ‚Äì 32 iterations only.*

---

### 3. C++

```cpp
#include <bits/stdc++.h>
using namespace std;

struct TrieNode {
    TrieNode* child[2];
    int cnt;
    TrieNode() { child[0] = child[1] = nullptr; cnt = 0; }
};

class Solution {
public:
    long long countXorSubarrays(vector<int>& nums, int k) {
        TrieNode* root = new TrieNode();
        insert(root, 0);                 // empty prefix
        long long res = 0;
        int pref = 0;

        for (int num : nums) {
            pref ^= num;
            res += query(root, pref, k);
            insert(root, pref);
        }
        return res;
    }

private:
    void insert(TrieNode* root, int val) {
        TrieNode* node = root;
        for (int i = 31; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (!node->child[bit]) node->child[bit] = new TrieNode();
            node = node->child[bit];
            node->cnt++;
        }
    }

    long long query(TrieNode* root, int pref, int k) {
        TrieNode* node = root;
        long long ans = 0;
        for (int i = 31; i >= 0 && node; --i) {
            int pBit = (pref >> i) & 1;
            int kBit = (k >> i) & 1;

            if (kBit) {                         // must take opposite bit
                node = node->child[1 - pBit];
            } else {                            // opposite bit gives >= k
                if (node->child[1 - pBit]) ans += node->child[1 - pBit]->cnt;
                node = node->child[pBit];
            }
        }
        if (node) ans += node->cnt;              // remaining nodes are valid
        return ans;
    }
};

// ---------- Driver for quick manual test ----------
int main() {
    Solution s;
    cout << s.countXorSubarrays({3,1,2,3}, 2) << endl;   // 6
    cout << s.countXorSubarrays({0,0,0}, 0) << endl;     // 6
    return 0;
}
```

> **C++ notes**:  
> *Pre‚Äëallocate nodes with `new` ‚Äì memory usage stays well below 10‚ÄØMB.*  
> *Use `long long` for the answer.*  
> *The 32‚Äëbit loop (`for (int i = 31; i >= 0; --i)`) guarantees constant time per number.*

---

## üìö Why This Is Interview‚ÄëReady

1. **Clean, O(1) per number** ‚Äì LeetCode hard requires you to think beyond the brute force.
2. **Shows mastery of**:
   * Prefix XOR ‚Äì a classic trick for sub‚Äëarray XOR problems.
   * Binary Trie ‚Äì a powerful data structure for bit‚Äëwise queries.
   * 64‚Äëbit integer arithmetic ‚Äì correctly handling overflow.
3. **Time & Space** ‚Äì Meets the strict limits (`O(n)` time, `O(n)` space).  
4. **Readability** ‚Äì Comments, consistent naming, and modular helper functions aid comprehension.

---

## üìà SEO‚ÄëOptimized Blog Article

### Subarrays with XOR‚ÄØ‚â•‚ÄØK ‚Äì The Good, the Bad, and the Ugly  
**(Hard LeetCode Problem #3632 ‚Äì 2025‚Äë09‚Äë26)**  

> **Keywords**: `leetcode hard`, `subarrays`, `xor`, `prefix XOR`, `binary trie`, `job interview algorithms`, `efficient algorithm`, `C++ solution`, `Java solution`, `Python solution`.

---

#### 1Ô∏è‚É£ Introduction

In the world of coding interviews, **LeetCode Hard** problems are the ultimate showcase of algorithmic brilliance.  
Problem 3632 ‚Äì *Subarrays with XOR at Least‚ÄØK* ‚Äì sits at the crossroads of bit manipulation, prefix sums, and trie data structures.  

If you want to land a software‚Äëengineering role, mastering this problem proves you can:

* Design solutions that are both **fast** and **memory‚Äëfriendly**.  
* Translate mathematical insights into clean code in multiple languages.  
* Communicate complex ideas clearly‚Äîan indispensable interview skill.

---

#### 2Ô∏è‚É£ Problem Statement

> **Given** an array `nums` of `n` integers (0‚ÄØ‚â§‚ÄØnums[i]‚ÄØ‚â§‚ÄØ2¬≥¬π‚ÄØ‚Äì‚ÄØ1) and an integer `K`.  
> **Task**: Count all sub‚Äëarrays `(i ‚Ä¶ j)` such that  
> `xor(nums[i..j])‚ÄØ‚â•‚ÄØK`.  

The naive approach examines every sub‚Äëarray: `O(n¬≤)`.  
With `n` up to 5‚ÄØ√ó‚ÄØ10‚Åµ, this is impossible on typical interview machines.

---

#### 3Ô∏è‚É£ The Good ‚Äì From Brute Force to Linear Time

| Approach | Time | Space | Verdict |
|----------|------|-------|---------|
| Brute force (double loop) | `O(n¬≤)` | `O(1)` | **Too slow** |
| Prefix XOR + hashmap | `O(n)` | `O(n)` | **Close**, but fails for the inequality case |
| **Binary Trie + Prefix XOR** | **`O(n)`** | `O(n)` | **Optimal** |

The *good* part: The optimal solution uses **prefix XOR** to transform the problem into a *prefix‚Äëbased inequality* that can be answered in constant time per element using a **binary trie**.

---

#### 4Ô∏è‚É£ The Bad ‚Äì Why the Simple Tricks Fail

- **HashMap approach**: You can count sub‚Äëarrays with XOR exactly equal to a target by storing prefix XOR counts in a hashmap.  
  However, for *at least K*, you need to know how many prefixes give a **range of XOR values**‚Äîhashmaps give you only *exact* matches.  
- **Sorting + two‚Äëpointer**: Works for sums but fails for XOR, because XOR isn‚Äôt monotonic with respect to array order.

These pitfalls illustrate why a naive solution will get a ‚ÄúTime Limit Exceeded‚Äù.

---

#### 5Ô∏è‚É£ The Ugly ‚Äì Common Pitfalls

| Pitfall | Symptom | Fix |
|---------|---------|-----|
| Using `int` for answer | Wrong result for large inputs | Use `long long` (C++), `long` (Java), or `int`‚Äëoverflow guard in Python |
| Forgetting the empty prefix | Misses sub‚Äëarrays that start at index 0 | Insert `0` into the trie before processing |
| Mis‚Äëhandling bit‚Äëordering | Off‚Äëby‚Äëone errors in inequality logic | Always iterate from the most significant bit (31) to 0 |
| Memory blow‚Äëup | `StackOverflowError` or `C++` heap exhaustion | Pre‚Äëallocate nodes carefully, avoid recursion for insert/query |

---

#### 6Ô∏è‚É£ Step‚Äëby‚ÄëStep Walk‚ÄëThrough (Java)

```java
// 1. Insert empty prefix
insert(root, 0);

// 2. For each number
prefix ^= num;                     // prefix XOR
ans += query(root, prefix, K);     // count qualifying prefixes
insert(root, prefix);              // add current prefix for future queries
```

*The `query` function navigates the trie bit by bit, deciding whether to take the opposite bit (to stay ‚â•‚ÄØK) or count all qualifying nodes.*

---

#### 7Ô∏è‚É£ Multi‚ÄëLanguage Templates

We provide full, compilable snippets in **Java**, **Python**, and **C++**.  
Feel free to copy, paste, and run them on your local IDE.  

| Language | File | Complexity |
|----------|------|------------|
| Java | `Solution.java` | `O(n)` |
| Python | `solution.py` | `O(n)` |
| C++ | `solution.cpp` | `O(n)` |

---

#### 8Ô∏è‚É£ Takeaway for Interviews

1. **Explain the intuition first**: *prefix XOR ‚Üí sub‚Äëarray XOR can be expressed as XOR of two prefixes.*  
2. **Show the data‚Äëstructure choice**: *binary trie gives us a logarithmic (constant) search over bits.*  
3. **Run through a small example on the whiteboard** to demonstrate the bit‚Äëby‚Äëbit logic.  

Remember, interviewers love to see *thinking on the fly*. If you hit a snag, ask clarifying questions about the range of `K` or the distribution of input values‚Äîthey might hint at a simpler solution or a subtle twist.

---

#### 9Ô∏è‚É£ Final Thoughts

Subarrays with XOR‚ÄØ‚â•‚ÄØK may look intimidating, but with a systematic approach‚Äîprefix XOR + binary trie‚Äîyou turn it into a clean, linear‚Äëtime algorithm.  

Drop the solution into your GitHub portfolio, use the discussion section to ask deeper questions, and be ready to discuss it in a technical interview.  

**Good luck, future software engineer!**

---

### üìå TL;DR

- **Problem**: Count sub‚Äëarrays with XOR‚ÄØ‚â•‚ÄØK.  
- **Optimal approach**: Prefix XOR + Binary Trie.  
- **Complexities**: `O(n)` time, `O(n)` space.  
- **Languages**: Java, Python, C++ (code above).  
- **Interview value**: Demonstrates advanced bit‚Äëwise reasoning, data‚Äëstructure selection, and performance awareness.  

---

> **Ready for the next hard problem?**  
> Try Problem‚ÄØ3631 ‚Äì *Maximum Sum of Subarrays with Equal Length* ‚Äì for a dynamic‚Äëprogramming twist.  

--- 

**Happy coding, and may your job interviews be glitch‚Äëfree!** üöÄ  

--- 

*End of article.*  

--- 

With these snippets and the article, you‚Äôre equipped to impress recruiters, ace the LeetCode hard challenge, and shine in your next interview. Happy solving!